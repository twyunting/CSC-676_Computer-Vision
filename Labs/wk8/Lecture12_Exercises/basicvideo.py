# -*- coding: utf-8 -*-
"""BasicVideo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12slvyYeDZd3XQ-ARELNouMtPUJnaCxwH
"""

# Temporal processing

import numpy as np
import cv2

cap = cv2.VideoCapture('bill.avi')

# list of video frames
frames = []

while(cap.isOpened()):
    # read frame from the video
    ret, frame = cap.read()
    
    if ret is False:
        break
        
    frames.append(frame)

cap.release()

# scale frame to 0-1
frames = np.array(frames) / 255.
print("frames size:", frames.shape, "# (nb_frames, height, width, channel)")

# get height, width
numFrames = frames.shape[0]
height = frames.shape[1]
width = frames.shape[2]

"""Exerciose 1: display space-time slice of the video. Slide 22. 

Import a short video, and create a 2D plot where Y axis is t and X-axis is n, which is the horizontal cross secxtion of the movie. See lecture 11, Slide 22. 
Hint: at each frame, take a vector of pixels at a fixed y-position and show an image of nFrames*nhorizontal pixels as a final image.

Exercise 2: Create a space-temporal Gaussian filter. See Slide 28. 
Gaussian temporal filtering (applied on a sequence of images) will blur the sequence evolution, smoothing out the temporal variation, like a rapid variation in illumination or movement of an object. It's a gaussian filtering of the signal obtained by the temporal evolution of each single pixel.

Exercise 2: Create a space-temporal Gaussian filter. See Slide 28. 
Gaussian temporal filtering (applied on a sequence of images) will blur the sequence evolution, smoothing out the temporal variation, like a rapid variation in illumination or movement of an object. It's a gaussian filtering of the signal obtained by the temporal evolution of each single pixel.
"""